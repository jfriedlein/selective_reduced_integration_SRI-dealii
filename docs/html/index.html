<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Selective reduced integration (SRI) in deal.II: Selective reduced integration (SRI) in deal.II</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Selective reduced integration (SRI) in deal.II
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Selective reduced integration (<a class="el" href="namespaceSRI.html">SRI</a>) in deal.II </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Selective reduced integration (<a class="el" href="namespaceSRI.html">SRI</a>) in deal.II</p><dl class="section author"><dt>Author</dt><dd>jfriedlein</dd></dl>
<h1><a class="anchor" id="code"></a>
The commented program</h1>
<div class="fragment"></div><!-- fragment --><p> Besides all your other includes, you now also include the <a class="el" href="namespaceSRI.html">SRI</a> file, for instance as follows: <br />
Selective Reduced Integration (<a class="el" href="namespaceSRI.html">SRI</a>) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../selective_reduced_integration_SRI-dealii/SRI.h&quot;</span></div><div class="line"> </div><div class="line">...</div></div><!-- fragment --><p> Then we go on and extent the deal.II typical main class, here named <em><a class="el" href="classSolid.html">Solid</a></em> </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classSolid.html">Solid</a></div><div class="line">{</div><div class="line">    ...</div></div><!-- fragment --><p> Later we need certain values, e.g. the shape gradients for the displacement components, so we define the following extractor <em>u_fe</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> FEValuesExtractors::Vector <a class="code" href="assembly__routine__SRI_8cc.html#ae50a49c136e49c33fcd5a555a00009dd">u_fe</a>; <span class="comment">// extractor for the dim displacement components</span></div></div><!-- fragment --><p> Here we delcare your typical QGauss quadrature rule <em>qf_cell</em> for the integration over the cell. We add another QGauss rule named <em>qf_cell_RI</em>. that will describe the reduced integration (RI). Furthermore, it is nice to add the <em>n_q_points_RI</em> that stores the number of QPs for the reduced integrations (for Q1SR elements that is always 1, but maybe you want to try Q2SR at some point) </p><div class="fragment"><div class="line"><span class="keyword">const</span> QGauss&lt;dim&gt;                <a class="code" href="assembly__routine__SRI_8cc.html#aaaceb34a5b42a4954b2e893607c1bdef">qf_cell</a>;</div><div class="line"><span class="keyword">const</span> QGauss&lt;dim&gt;                <a class="code" href="assembly__routine__SRI_8cc.html#ab9727a7376e2656d3cd40c65ac7efb81">qf_cell_RI</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               <a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              <a class="code" href="assembly__routine__SRI_8cc.html#a0b72b2a33d52b7597b87df35b5b92415">n_q_points_RI</a>;</div></div><!-- fragment --><p> A flag to decide whether we want to use <a class="el" href="namespaceSRI.html">SRI</a> (actually I always use a parameter in the prm file to change element formulations) </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="assembly__routine__SRI_8cc.html#a535468030220abae9305a26e9d7f7401">SRI_active</a> = <span class="keyword">true</span>;</div></div><!-- fragment --><p> You can decide whether you want to do a volumetric-deviatoric split "vol_dev_split" to alleviate volumetric locking or a shear-normal split "shear_normal_split" to counteract shear locking. For this an enumerator was declared inside the function in the namespace <em>enums</em> </p><div class="fragment"><div class="line">     <a class="code" href="namespaceenums.html#ad159a7d6539f111883db3b07c09601a8">enums::enum_SRI_type</a> <a class="code" href="assembly__routine__SRI_8cc.html#a163566963ded80f68a5bbc6d04ce0adf">SRI_type</a> = <a class="code" href="namespaceenums.html#ad159a7d6539f111883db3b07c09601a8ad2c871b65148302b24a39fac6cedfd40">enums::vol_dev_split</a>;</div><div class="line"> </div><div class="line">     ...</div><div class="line">}</div></div><!-- fragment --><p> Constructor </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="assembly__routine__SRI_8cc.html#a031582e4b219de9cc57c78ebd20a2fc3">Solid&lt;dim&gt;::Solid</a>( ... )</div><div class="line">:</div><div class="line">...</div></div><!-- fragment --><p> Here we choose a standard <em>FE_Q</em> (just so you know) </p><div class="fragment"><div class="line">fe( FE_Q&lt;dim&gt;(degree), dim),    <span class="comment">// displacement</span></div><div class="line"><a class="code" href="assembly__routine__SRI_8cc.html#ae50a49c136e49c33fcd5a555a00009dd">u_fe</a>(0),</div></div><!-- fragment --><p> In the constructor for the above main class, we now also have to initialise the new variables, which we do as follows </p><div class="fragment"><div class="line"><a class="code" href="assembly__routine__SRI_8cc.html#aaaceb34a5b42a4954b2e893607c1bdef">qf_cell</a>( degree +1 )</div><div class="line"><a class="code" href="assembly__routine__SRI_8cc.html#ab9727a7376e2656d3cd40c65ac7efb81">qf_cell_RI</a>( degree +1 -1 ),</div><div class="line"><a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a> (<a class="code" href="assembly__routine__SRI_8cc.html#aaaceb34a5b42a4954b2e893607c1bdef">qf_cell</a>.size()),</div><div class="line"><a class="code" href="assembly__routine__SRI_8cc.html#a0b72b2a33d52b7597b87df35b5b92415">n_q_points_RI</a> ( <a class="code" href="assembly__routine__SRI_8cc.html#a535468030220abae9305a26e9d7f7401">SRI_active</a> ? (<a class="code" href="assembly__routine__SRI_8cc.html#ab9727a7376e2656d3cd40c65ac7efb81">qf_cell_RI</a>.size()) : 0 ),</div><div class="line">...</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> Assemble one-field finite strain over material configuration <br />
We emphasis the relevant changes in the comment by a leading [<a class="el" href="namespaceSRI.html">SRI</a>] </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html">Solid&lt;dim&gt;::assemble_system_fstrain</a>( <span class="comment">/*output-&gt; tangent_matrix, system_rhs*/</span> )</div><div class="line">{</div></div><!-- fragment --><p> FEValues and FaceValues to compute quantities on quadrature points for our finite element space including mapping from the real cell. There are no requirements on this <em></em>  and  for <a class="el" href="namespaceSRI.html">SRI</a>, so you can keep your standard code for these. </p><div class="fragment"><div class="line">FEValues&lt;dim&gt; fe_values_ref (  fe,<span class="comment">//The used FiniteElement</span></div><div class="line">                               <a class="code" href="assembly__routine__SRI_8cc.html#aaaceb34a5b42a4954b2e893607c1bdef">qf_cell</a>,<span class="comment">//The quadrature rule for the cell</span></div><div class="line">                               update_values| <span class="comment">//UpdateFlag for shape function values</span></div><div class="line">                               update_gradients| <span class="comment">//shape function gradients</span></div><div class="line">                               update_JxW_values|  <span class="comment">//transformed quadrature weights multiplied with Jacobian of transformation</span></div><div class="line">                               update_quadrature_points );</div><div class="line"></div><div class="line">FEFaceValues&lt;dim&gt; fe_face_values_ref ( fe,</div><div class="line">                                       qf_face, <span class="comment">//The quadrature for face quadrature points</span></div><div class="line">                                       update_values|</div><div class="line">                                       update_gradients|</div><div class="line">                                       update_normal_vectors| <span class="comment">//compute normal vector for face</span></div><div class="line">                                       update_JxW_values|</div><div class="line">                                       update_quadrature_points|</div><div class="line">                                       update_jacobians );</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] In addition for SRIs we define the reduced integration rule </p><div class="fragment"><div class="line">FEValues&lt;dim&gt; fe_values_ref_RI (   fe,<span class="comment">//The used FiniteElement</span></div><div class="line">                                   <a class="code" href="assembly__routine__SRI_8cc.html#ab9727a7376e2656d3cd40c65ac7efb81">qf_cell_RI</a>,<span class="comment">//The quadrature rule for the cell</span></div><div class="line">                                   update_values | <span class="comment">//UpdateFlag for shape function values</span></div><div class="line">                                   update_gradients | <span class="comment">//shape function gradients</span></div><div class="line">                                   update_JxW_values );  <span class="comment">//transformed quadrature weights multiplied with Jacobian of transformation</span></div></div><!-- fragment --><p> Quantities to store the local rhs and matrix contribution </p><div class="fragment"><div class="line">FullMatrix&lt;double&gt; cell_matrix(dofs_per_cell,dofs_per_cell);</div><div class="line">Vector&lt;double&gt; cell_rhs (dofs_per_cell);</div></div><!-- fragment --><p> Vector with the indices (global) of the local dofs </p><div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p> Compute the current, total solution, i.e. starting value of current load step and current solution_delta </p><div class="fragment"><div class="line">Vector&lt;double&gt; current_solution = get_total_solution(this-&gt;solution_delta);</div></div><!-- fragment --><p> Tangents class and Tangent members </p><div class="fragment"><div class="line">Tangent_groups_u&lt;dim&gt; Tangents;</div><div class="line">SymmetricTensor&lt;4,dim&gt; Tangent;</div><div class="line">SymmetricTensor&lt;2,dim&gt; Tangent_theta;</div></div><!-- fragment --><p> Iterators to loop over all active cells </p><div class="fragment"><div class="line"> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator cell = dof_handler_ref.begin_active(),</div><div class="line">                                                endc = dof_handler_ref.end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(;cell!=endc;++cell)</div><div class="line">{</div></div><!-- fragment --><p> Reset the local rhs and matrix for every cell </p><div class="fragment"><div class="line">cell_matrix=0.0;</div><div class="line">cell_rhs=0.0;</div></div><!-- fragment --><p> Reinit the FEValues instance for the current cell, i.e. compute the values for the current cell </p><div class="fragment"><div class="line">fe_values_ref.reinit(cell);</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] Also reinit the RI rule for <a class="el" href="namespaceSRI.html">SRI</a> </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="assembly__routine__SRI_8cc.html#a535468030220abae9305a26e9d7f7401">SRI_active</a> )</div><div class="line">   fe_values_ref_RI.reinit(cell);</div></div><!-- fragment --><p> Vector to store the gradients of the solution at n_q_points quadrature points </p><div class="fragment"><div class="line">std::vector&lt;Tensor&lt;2,dim&gt; &gt; solution_grads_u(<a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a>);</div></div><!-- fragment --><p> Fill the previous vector using get_function_gradients </p><div class="fragment"><div class="line">fe_values_ref[<a class="code" href="assembly__routine__SRI_8cc.html#ae50a49c136e49c33fcd5a555a00009dd">u_fe</a>].get_function_gradients(current_solution,solution_grads_u);</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] Prepare the solutions gradients for the RI rule. Herein we extend the given vector of solution gradients by the additional gradients at the reduced integration quadrature points. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="assembly__routine__SRI_8cc.html#a535468030220abae9305a26e9d7f7401">SRI_active</a> )</div><div class="line">    <a class="code" href="namespaceSRI.html#add98d0fc70a6c51803dfd8c491547413">SRI::prepare_solGrads</a>( <a class="code" href="assembly__routine__SRI_8cc.html#a0b72b2a33d52b7597b87df35b5b92415">n_q_points_RI</a>, fe_values_ref_RI, current_solution, solution_grads_u );</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] k_rel is the relative qp-counter used for everything related to FEValues objects and needed for <a class="el" href="namespaceSRI.html">SRI</a> </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_rel = 0;</div></div><!-- fragment --><p> Write the global indices of the local dofs of the current cell </p><div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p> Get the QPH for the QPs of the current cell, all stored in one vector of pointers </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt; std::shared_ptr&lt; PointHistory&lt;dim&gt; &gt; &gt; lqph = quadrature_point_history.get_data(cell);</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] Loop over all quadrature points of the cell <br />
For <a class="el" href="namespaceSRI.html">SRI</a> the variable <em>n_q_points_RI</em> contains the number of QPs for reduced integration over which we also loop. Else (FuI, RI, Fbar) this number is zero, so we don't loop over these additional QPs </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k &lt; (<a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a>+<a class="code" href="assembly__routine__SRI_8cc.html#a0b72b2a33d52b7597b87df35b5b92415">n_q_points_RI</a>); ++k )</div><div class="line">{</div></div><!-- fragment --><p> Compute the deformation gradient from the solution gradients. Note that the vector of solutions gradients has been, in case of <a class="el" href="namespaceSRI.html">SRI</a>, been extended by the values at the RI QPs, so we have to use the full QP counter <em>k</em>. </p><dl class="section note"><dt>Note</dt><dd>If you want to work with 2D or even axisymmetry, you would need to modify the deformation gradient now and cross some more t's (see <a href="https://github.com/jfriedlein/2D_axial-symmetry_plane-strain_dealii">https://github.com/jfriedlein/2D_axial-symmetry_plane-strain_dealii</a>).</dd></dl>
<div class="fragment"><div class="line">Tensor&lt;2,dim&gt; DeformationGradient = (Tensor&lt;2, dim&gt;(StandardTensors::I&lt;dim&gt;()) + solution_grads_u[k]);</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] <a class="el" href="namespaceSRI.html">SRI</a> (does no harm to the remaining ELFORMs) <br />
We initalise the <em>fe_values_part</em> pointer with the currently needed FEValues quantity. For the first <em>n_q_points</em> quadrature points we assign the standard <em>fe_values_ref</em> and in the remaining <em>n_q_points_RI</em> we use the <em>fe_values_ref_RI</em> for the reduced integration </p><div class="fragment"><div class="line">FEValues&lt;dim&gt; *fe_values_part = <span class="keyword">nullptr</span>;</div><div class="line"><a class="code" href="namespaceSRI.html#a304be230ce6414b79b92c2921ad38524">SRI::init_fe_k</a>( <span class="comment">/*input-&gt;*/</span> fe_values_ref, fe_values_ref_RI, k, <a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a>,</div><div class="line">                <span class="comment">/*output-&gt;*/</span> fe_values_part, k_rel );</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] We declare *_part variables for the stress and the tangent, that eiter contain the deviatoric or volumetric parts </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; stress_part;</div><div class="line">SymmetricTensor&lt;4,dim&gt; Tangent_part;</div></div><!-- fragment --><p> The material model will still return the full stress and tangents, because we call it with the standard deformation gradient. Thus, we also create the full stress and tangent as tensor. (There is certainly a more efficient way to do this.) </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; stress_S;</div><div class="line">SymmetricTensor&lt;4,dim&gt; dS_dC;</div></div><!-- fragment --><p> Now you have to call your material model with the deformation gradient and whatever else, to get your stress and tangent. The following is just a dummy and far from my actual code. </p><div class="fragment"><div class="line">elastoplasticity( DeformationGradient, lqph[k], stress_S, dS_dC );</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] Extract the desired parts from the stress and tangent, in case we use <a class="el" href="namespaceSRI.html">SRI</a>. Depending on the <em>SRI_type</em>, we now do either a volumetric-deviatoric split or a trivial normal-shear split. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="assembly__routine__SRI_8cc.html#a535468030220abae9305a26e9d7f7401">SRI_active</a> )</div><div class="line">{</div><div class="line">   stress_part = SRI::part&lt;dim&gt;( DeformationGradient, stress_S, SRi_type, k, <a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a> );</div><div class="line">   Tangent_part = SRI::part&lt;dim&gt;( DeformationGradient, stress_S, dS_dC, <a class="code" href="assembly__routine__SRI_8cc.html#a163566963ded80f68a5bbc6d04ce0adf">SRI_type</a>, k, <a class="code" href="assembly__routine__SRI_8cc.html#afd52b693751274175b93a58458201e6b">n_q_points</a> );</div><div class="line">}</div></div><!-- fragment --><p> For full integration, we just copy the full tensors into the *_part variables </p><div class="fragment"><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">   stress_part = stress_S;</div><div class="line">   Tangent_part = dS_dC;</div><div class="line">}</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] The quadrature weight for the current quadrature point. That seems to be a daily task, but due to the variable FEValues element you have to use the general *_part variable and the relative QP counter <em>k_rel</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> JxW = (*fe_values_part).JxW(k_rel);</div></div><!-- fragment --><p> Loop over all dof's of the cell </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; dofs_per_cell; ++i)</div><div class="line">{</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] Assemble system_rhs contribution Here we also access the FEValues, so we replace this by the _part counterpart together with <em>k-rel</em> </p><div class="fragment"><div class="line">Tensor&lt;2,dim&gt; grad_X_N_u_i = (*fe_values_part)[<a class="code" href="assembly__routine__SRI_8cc.html#ae50a49c136e49c33fcd5a555a00009dd">u_fe</a>].gradient(i,k_rel);</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] The standard residual as shown on GitHub. Note that this is exactly the same as without <a class="el" href="namespaceSRI.html">SRI</a>, only that we replace the PK2 stress by the stress part  that either contains the volumetric or deviatoric stress (or normal-shear) </p><div class="fragment"><div class="line">cell_rhs(i) -= ( symmetrize( transpose(DeformationGradient) * grad_X_N_u_i ) * stress_part ) * JxW;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">{</div></div><!-- fragment --><p> [<a class="el" href="namespaceSRI.html">SRI</a>] Assemble tangent contribution </p><div class="fragment"><div class="line">Tensor&lt;2,dim&gt; grad_X_N_u_j = (*fe_values_part)[<a class="code" href="assembly__routine__SRI_8cc.html#ae50a49c136e49c33fcd5a555a00009dd">u_fe</a>].gradient(j,k_rel);</div></div><!-- fragment --><p> The linearisation of the right Cauchy-Green tensor (You will recall this line when you take a closer look at the F-bar formulation) </p><div class="fragment"><div class="line">SymmetricTensor&lt;2,dim&gt; deltaRCG = 2. * symmetrize( transpose(grad_X_N_u_j) * DeformationGradient );</div></div><!-- fragment --><p> Again, the only difference to the standard integration, is that we replace the stress and now also the tangent by the *_part counterparts. That's it! </p><div class="fragment"><div class="line">            cell_matrix(i,j) += (</div><div class="line">                                    symmetrize( transpose(grad_X_N_u_i) * grad_X_N_u_j ) * stress_part</div><div class="line">                                    +</div><div class="line">                                    symmetrize( transpose(DeformationGradient) * grad_X_N_u_i )</div><div class="line">                                      ( Tangent_part * deltaRCG )</div><div class="line">                                )</div><div class="line">                                  JxW;</div><div class="line">        } <span class="comment">// end for(j)</span></div><div class="line">     } <span class="comment">// end for(i)</span></div><div class="line">} <span class="comment">// end for(k)</span></div></div><!-- fragment --><p> Copy local to global: </p><div class="fragment"><div class="line">        constraints.distribute_local_to_global(cell_matrix,cell_rhs,</div><div class="line">                                local_dof_indices,</div><div class="line">                                tangent_matrix,system_rhs,<span class="keyword">false</span>);</div><div class="line">    } <span class="comment">// end for(cell)</span></div><div class="line">} <span class="comment">// end assemble_system</span></div></div><!-- fragment --><h1><a class="anchor" id="END"></a>
The End</h1>
<p>Hosted via GitHub according to <a href="https://goseeky.wordpress.com/2017/07/22/documentation-101-doxygen-with-github-pages/">https://goseeky.wordpress.com/2017/07/22/documentation-101-doxygen-with-github-pages/</a> <br />
Design of the documentation inspired by the deal.ii tutorial programs. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
